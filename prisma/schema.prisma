// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum UserType {
  PERSON
  COMPANY
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_VERIFICATION
}

model User {
  id                String     @id @default(cuid())
  email             String     @unique
  googleId          String?    @unique  // ← Agregado @unique
  facebookId        String?    @unique  // ← Agregado @unique
  password          String
  firstName         String
  lastName          String
  phone             String?
  avatar            String?
  role              UserRole   @default(USER)
  type              UserType   @default(PERSON)
  status            UserStatus @default(PENDING_VERIFICATION)
  isEmailVerified   Boolean    @default(false)
  emailVerifiedAt   DateTime?
  lastLoginAt       DateTime?
  referralCode      String     @unique
  referredBy        String?
  companyName       String?
  companyDocument   String?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  // Relations
  wallet              Wallet?
  orders              Order[]
  bankAccounts        BankAccount[]
  referrals           User[]     @relation("UserReferrals")
  referrer            User?      @relation("UserReferrals", fields: [referredBy], references: [referralCode])
  pointsTransactions  PointsTransaction[]
  notifications       Notification[]
  sessions            UserSession[]
  refreshTokens       RefreshToken[]
  tokenBlacklist      TokenBlacklist[]
  verificationTokens  VerificationToken[]
  oauthAccounts       OAuthAccount[]

  @@map("users")
}

model UserSession {
  id          String   @id @default(cuid())
  userId      String
  token       String   @unique
  accessToken String?  // ← Campo opcional para access token
  userAgent   String?
  ipAddress   String?
  isActive    Boolean  @default(true)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt  // ← Agregado @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])      // ← Agregado índice
  @@index([expiresAt])   // ← Agregado índice
  @@map("user_sessions")
}

// Enums para las nuevas categorías
enum CategoryType {
  COMPLETE_DEVICES      // Dispositivos Completos
  DISMANTLED_DEVICES    // Dispositivos Desarmables
}

enum DeviceCondition {
  EXCELLENT
  GOOD
  FAIR
  POOR
  BROKEN
}

enum MaterialGrade {
  LOW_GRADE_GREEN       // Bajo Grado → Verde
  LOW_GRADE_BROWN       // Bajo Grado → Marrón
  HIGH_GRADE_CIRCUIT    // Alto Grado → Circuitos
  MIXED_COMPONENTS      // Componentes Mixtos
  PENTIUM_III          // Pentium III
  PENTIUM_IV           // Pentium IV
  MEDIUM_GRADE         // Medio Grado
}

enum ClassificationLevel {
  MAIN_TYPE            // Dispositivos Completos / Desarmables
  GRADE_LEVEL          // Bajo/Medio/Alto Grado
  SUB_CATEGORY         // Específico (Verde, Marrón, etc.)
  DEVICE_TYPE          // Tipo específico (Tablet, Laptop, etc.)
}

enum CategoryStatus {
  ACTIVE
  INACTIVE
}

// Modelo principal de categorías actualizado
model Category {
  id              String         @id @default(cuid())
  name            String
  description     String?
  type            CategoryType   // COMPLETE_DEVICES o DISMANTLED_DEVICES
  icon            String?
  image           String?        // Imagen principal para mostrar en UI
  status          CategoryStatus @default(ACTIVE)
  
  // Clasificación jerárquica
  materialGrade     MaterialGrade?       // Grado del material
  classificationLevel ClassificationLevel @default(DEVICE_TYPE)
  parentCategoryId  String?             // Para estructura jerárquica
  hierarchyPath     String[]            @default([]) // Path completo ["Bajo Grado", "Verde", "Verde/Amarillo"]
  sortOrder         Int                 @default(0)  // Orden de visualización
  
  // Para dispositivos completos
  estimatedWeight Decimal?       @db.Decimal(8, 3)  // Peso promedio en kg
  basePrice       Decimal        @db.Decimal(10, 2) // Precio base por kg o por unidad
  
  // Para dispositivos desarmables  
  pricePerKg      Decimal        @db.Decimal(10, 2) // Precio por kg
  
  // Rangos de precio
  minPrice        Decimal        @db.Decimal(10, 2)
  maxPrice        Decimal        @db.Decimal(10, 2)
  
  // Referencias visuales
  referenceImages String[]       @default([])  // URLs de imágenes de referencia
  examples        String[]       @default([])  // Ejemplos de productos
  
  // Campos requeridos para esta categoría
  requiredFields  String[]       @default([])  // ["brand", "model", "condition"]
  
  // Multiplicadores por condición (JSON)
  conditionMultipliers Json?      // { "excellent": 1.0, "good": 0.8, ... }
  
  // Configuración adicional
  allowsQuantity  Boolean        @default(true)   // Si permite cantidad múltiple
  requiresPhotos  Boolean        @default(true)   // Si requiere fotos obligatorias
  minPhotos       Int            @default(1)      // Mínimo de fotos requeridas
  maxPhotos       Int            @default(10)     // Máximo de fotos permitidas
  
  // Campos específicos para clasificación detallada
  deviceFamily    String?        // Familia del dispositivo (ej: "Pentium IV", "Boards tipo 1")
  qualityGrade    String?        // Grado de calidad (ej: "Buena", "Mala")
  chipCount       Int?           // Número de chips (para Pentium)
  boardType       String?        // Tipo de placa específico
  
  // Información de ayuda para el usuario
  identificationHelp String?     // Texto de ayuda para identificar el dispositivo
  commonMistakes   String[]      @default([]) // Errores comunes de clasificación
  expertTips       String[]      @default([]) // Tips para expertos
  
  // Metadata y timestamps
  metadata        Json?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Relations
  parentCategory  Category?      @relation("CategoryHierarchy", fields: [parentCategoryId], references: [id])
  childCategories Category[]     @relation("CategoryHierarchy")
  orderItems      OrderItem[]

  @@index([type])
  @@index([status])
  @@index([materialGrade])
  @@index([classificationLevel])
  @@index([parentCategoryId])
  @@index([sortOrder])
  @@map("categories")
}

enum OrderStatus {
  PENDING
  CONFIRMED
  IN_TRANSIT
  DELIVERED
  VERIFIED
  PAID
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum DeliveryMethod {
  PICKUP_POINT
  HOME_PICKUP
}

model Order {
  id                String         @id @default(cuid())
  orderNumber       String         @unique
  userId            String
  status            OrderStatus    @default(PENDING)
  paymentStatus     PaymentStatus  @default(PENDING)
  deliveryMethod    DeliveryMethod
  estimatedTotal    Decimal        @db.Decimal(10, 2)
  finalTotal        Decimal?       @db.Decimal(10, 2)
  estimatedWeight   Decimal        @db.Decimal(8, 3)
  actualWeight      Decimal?       @db.Decimal(8, 3)
  notes             String?
  
  // Pickup/Delivery info
  pickupAddress     Json?
  pickupDate        DateTime?
  deliveryDate      DateTime?
  trackingNumber    String?
  qrCode            String?
  
  // Servientrega integration
  servientregaGuide String?
  servientregaStatus String?
  
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  // Relations
  user              User           @relation(fields: [userId], references: [id])
  orderItems        OrderItem[]
  walletTransactions WalletTransaction[]

  @@index([userId])        // ← Agregado índice
  @@index([status])        // ← Agregado índice
  @@index([orderNumber])   // ← Agregado índice
  @@map("orders")
}

// Actualizar el modelo OrderItem para incluir nueva info
model OrderItem {
  id              String   @id @default(cuid())
  orderId         String
  categoryId      String
  
  // Información del dispositivo/material
  deviceName      String?        // Nombre específico del dispositivo
  brand           String?        // Marca
  model           String?        // Modelo
  condition       DeviceCondition? // Estado del dispositivo
  
  // Campos específicos según clasificación
  processorModel  String?        // Para Pentium III/IV
  socketType      String?        // Tipo de socket
  frequency       String?        // Frecuencia del procesador
  coreCount       Int?           // Número de núcleos
  storageCapacity String?        // Para tablets/laptops
  processorType   String?        // Tipo de procesador
  decoderType     String?        // Tipo de decodificador
  resolution      String?        // Resolución soportada
  deviceType      String?        // Tipo específico de dispositivo
  readerType      String?        // Tipo de lector
  printerType     String?        // Tipo de impresora
  connectivity    String?        // Tipo de conectividad
  systemType      String?        // Tipo de sistema
  manufacturer    String?        // Fabricante específico
  networkStandard String?        // Estándar de red
  equipmentType   String?        // Tipo de equipo
  networkTier     String?        // Nivel de red
  capacity        String?        // Capacidad del equipo
  approximateAge  String?        // Edad aproximada
  componentType   String?        // Tipo de componente
  authenticity    String?        // Autenticidad del componente
  formFactor      String?        // Factor de forma
  brandFeatures   String?        // Características de marca
  damageType      String?        // Tipo de daño
  systemModel     String?        // Modelo del sistema
  enterpriseGrade Boolean?       // Si es grado empresarial
  
  // Cantidades y pesos
  quantity        Int            @default(1)    // Cantidad de dispositivos
  estimatedWeight Decimal        @db.Decimal(8, 3)
  actualWeight    Decimal?       @db.Decimal(8, 3)
  
  // Precios
  pricePerKg      Decimal        @db.Decimal(10, 2)
  pricePerUnit    Decimal?       @db.Decimal(10, 2)  // Para dispositivos completos
  estimatedValue  Decimal        @db.Decimal(10, 2)
  actualValue     Decimal?       @db.Decimal(10, 2)
  
  // Evidencia y notas
  images          String[]       @default([])
  notes           String?
  
  // Accesorios incluidos (para dispositivos completos)
  accessories     String[]       @default([])  // ["charger", "box", "documents"]
  
  // Metadata adicional
  metadata        Json?
  
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Relations
  order           Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  category        Category       @relation(fields: [categoryId], references: [id])

  @@index([orderId])
  @@index([categoryId])
  @@index([condition])
  @@map("order_items")
}

enum WalletStatus {
  ACTIVE
  SUSPENDED
  CLOSED
}

model Wallet {
  id                String    @id @default(cuid())
  userId            String    @unique
  balance           Decimal   @default(0.00) @db.Decimal(12, 2)
  availableBalance  Decimal   @default(0.00) @db.Decimal(12, 2)
  pendingBalance    Decimal   @default(0.00) @db.Decimal(12, 2)
  currency          String    @default("USD")
  status            WalletStatus @default(ACTIVE)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions      WalletTransaction[]
  withdrawals       Withdrawal[]

  @@map("wallets")
}

enum TransactionType {
  CREDIT
  DEBIT
  HOLD
  RELEASE
  FEE
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

model WalletTransaction {
  id                  String            @id @default(cuid())
  walletId            String
  orderId             String?
  type                TransactionType
  amount              Decimal           @db.Decimal(12, 2)
  fee                 Decimal           @default(0.00) @db.Decimal(12, 2)
  balanceAfter        Decimal           @db.Decimal(12, 2)
  status              TransactionStatus @default(PENDING)
  description         String?
  metadata            Json?
  kushkiTransactionId String?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  // Relations
  wallet              Wallet            @relation(fields: [walletId], references: [id], onDelete: Cascade)
  order               Order?            @relation(fields: [orderId], references: [id])

  @@index([walletId])  // ← Agregado índice
  @@index([orderId])   // ← Agregado índice
  @@index([status])    // ← Agregado índice
  @@map("wallet_transactions")
}

enum BankAccountType {
  SAVINGS
  CHECKING
}

enum DocumentType {
  CEDULA
  PASSPORT
  RUC
}

model BankAccount {
  id                String          @id @default(cuid())
  userId            String
  bankName          String
  bankCode          String
  accountNumber     String
  accountType       BankAccountType
  accountHolderName String
  documentType      DocumentType
  documentNumber    String
  isDefault         Boolean         @default(false)
  isVerified        Boolean         @default(false)
  kushkiAccountId   String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  // Relations
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  withdrawals       Withdrawal[]

  @@unique([userId, accountNumber])
  @@index([userId])    // ← Agregado índice adicional
  @@map("bank_accounts")
}

enum WithdrawalStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

model Withdrawal {
  id                String           @id @default(cuid())
  walletId          String
  bankAccountId     String
  amount            Decimal          @db.Decimal(12, 2)
  kushkiFee         Decimal          @db.Decimal(12, 2)
  netAmount         Decimal          @db.Decimal(12, 2)
  status            WithdrawalStatus @default(PENDING)
  kushkiTransferId  String?
  processingDate    DateTime?
  completedDate     DateTime?
  errorMessage      String?
  metadata          Json?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  // Relations
  wallet            Wallet           @relation(fields: [walletId], references: [id])
  bankAccount       BankAccount      @relation(fields: [bankAccountId], references: [id])

  @@index([walletId])       // ← Agregado índice
  @@index([bankAccountId])  // ← Agregado índice
  @@index([status])         // ← Agregado índice
  @@map("withdrawals")
}

model PointsTransaction {
  id          String   @id @default(cuid())
  userId      String
  points      Int
  type        String   // 'earned', 'redeemed', 'bonus'
  source      String   // 'order', 'referral', 'manual'
  sourceId    String?  // order_id, referral_id, etc.
  description String?
  createdAt   DateTime @default(now())

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])  // ← Agregado índice
  @@map("points_transactions")
}

enum NotificationType {
  ORDER_UPDATE
  PAYMENT_RECEIVED
  WITHDRAWAL_COMPLETED
  VERIFICATION_REQUIRED
  SYSTEM_MAINTENANCE
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
}

model Notification {
  id        String             @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  status    NotificationStatus @default(UNREAD)
  metadata  Json?
  createdAt DateTime           @default(now())
  readAt    DateTime?

  // Relations
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])  // ← Agregado índice
  @@index([status])  // ← Agregado índice
  @@map("notifications")
}

model SystemSetting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  type      String   // 'string', 'number', 'boolean', 'json'
  category  String   // 'general', 'payment', 'email', etc.
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])  // ← Agregado índice
  @@map("system_settings")
}

// Tokens de verificación
enum TokenType {
  EMAIL_VERIFICATION
  PASSWORD_RESET
  CHANGE_EMAIL
}

model VerificationToken {
  id        String     @id @default(cuid())
  userId    String
  token     String     @unique
  type      TokenType
  expiresAt DateTime
  isUsed    Boolean    @default(false)
  usedAt    DateTime?
  metadata  Json?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])    // ← Agregado índice
  @@index([expiresAt]) // ← Agregado índice
  @@index([type])      // ← Agregado índice
  @@map("verification_tokens")
}

// OAuth Accounts (Google, Facebook, etc.)
enum OAuthProvider {
  GOOGLE
  FACEBOOK
}

model OAuthAccount {
  id                String        @id @default(cuid())
  userId            String
  provider          OAuthProvider
  providerAccountId String        
  accessToken       String?       @db.Text
  refreshToken      String?       @db.Text
  expiresAt         DateTime?
  tokenType         String?
  scope             String?
  idToken           String?       @db.Text
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])    // ← Agregado índice
  @@map("oauth_accounts")
}

model RefreshToken {
  id          String   @id @default(cuid())
  token       String   @unique
  userId      String
  isActive    Boolean  @default(true)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relaciones
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Índices para optimizar consultas
  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model TokenBlacklist {
  id          String   @id @default(cuid())
  tokenHash   String   @unique // Hash SHA256 del token
  userId      String
  expiresAt   DateTime // Fecha de expiración del token original
  reason      String   // Razón por la cual se agregó a la blacklist
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relaciones
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Índices para optimizar consultas
  @@index([userId])
  @@index([expiresAt])
  @@index([tokenHash])
  @@map("token_blacklist")
}