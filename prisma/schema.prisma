// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum UserType {
  PERSON
  COMPANY
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_VERIFICATION
}

model User {
  id                String     @id @default(cuid())
  email             String     @unique
  googleId          String?    @unique  // ← Agregado @unique
  facebookId        String?    @unique  // ← Agregado @unique
  password          String
  firstName         String
  lastName          String
  phone             String?
  avatar            String?
  role              UserRole   @default(USER)
  type              UserType   @default(PERSON)
  status            UserStatus @default(PENDING_VERIFICATION)
  isEmailVerified   Boolean    @default(false)
  emailVerifiedAt   DateTime?
  lastLoginAt       DateTime?
  referralCode      String     @unique
  referredBy        String?
  companyName       String?
  companyDocument   String?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  // Relations
  wallet              Wallet?
  orders              Order[]
  bankAccounts        BankAccount[]
  referrals           User[]     @relation("UserReferrals")
  referrer            User?      @relation("UserReferrals", fields: [referredBy], references: [referralCode])
  pointsTransactions  PointsTransaction[]
  notifications       Notification[]
  sessions            UserSession[]
  refreshTokens       RefreshToken[]
  tokenBlacklist      TokenBlacklist[]
  verificationTokens  VerificationToken[]
  oauthAccounts       OAuthAccount[]

  @@map("users")
}

model UserSession {
  id          String   @id @default(cuid())
  userId      String
  token       String   @unique
  accessToken String?  // ← Campo opcional para access token
  userAgent   String?
  ipAddress   String?
  isActive    Boolean  @default(true)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt  // ← Agregado @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])      // ← Agregado índice
  @@index([expiresAt])   // ← Agregado índice
  @@map("user_sessions")
}

enum CategoryStatus {
  ACTIVE
  INACTIVE
}

model Category {
  id              String         @id @default(cuid())
  name            String
  description     String?
  pricePerKg      Decimal        @db.Decimal(10, 2)
  image           String?
  status          CategoryStatus @default(ACTIVE)
  estimatedWeight Decimal?       @db.Decimal(8, 3)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Relations
  orderItems      OrderItem[]

  @@map("categories")
}

enum OrderStatus {
  PENDING
  CONFIRMED
  IN_TRANSIT
  DELIVERED
  VERIFIED
  PAID
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum DeliveryMethod {
  PICKUP_POINT
  HOME_PICKUP
}

model Order {
  id                String         @id @default(cuid())
  orderNumber       String         @unique
  userId            String
  status            OrderStatus    @default(PENDING)
  paymentStatus     PaymentStatus  @default(PENDING)
  deliveryMethod    DeliveryMethod
  estimatedTotal    Decimal        @db.Decimal(10, 2)
  finalTotal        Decimal?       @db.Decimal(10, 2)
  estimatedWeight   Decimal        @db.Decimal(8, 3)
  actualWeight      Decimal?       @db.Decimal(8, 3)
  notes             String?
  
  // Pickup/Delivery info
  pickupAddress     Json?
  pickupDate        DateTime?
  deliveryDate      DateTime?
  trackingNumber    String?
  qrCode            String?
  
  // Servientrega integration
  servientregaGuide String?
  servientregaStatus String?
  
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  // Relations
  user              User           @relation(fields: [userId], references: [id])
  orderItems        OrderItem[]
  walletTransactions WalletTransaction[]

  @@index([userId])        // ← Agregado índice
  @@index([status])        // ← Agregado índice
  @@index([orderNumber])   // ← Agregado índice
  @@map("orders")
}

model OrderItem {
  id              String   @id @default(cuid())
  orderId         String
  categoryId      String
  estimatedWeight Decimal  @db.Decimal(8, 3)
  actualWeight    Decimal? @db.Decimal(8, 3)
  pricePerKg      Decimal  @db.Decimal(10, 2)
  estimatedValue  Decimal  @db.Decimal(10, 2)
  actualValue     Decimal? @db.Decimal(10, 2)
  images          String[] @default([])
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  order           Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  category        Category @relation(fields: [categoryId], references: [id])

  @@index([orderId])     // ← Agregado índice
  @@index([categoryId])  // ← Agregado índice
  @@map("order_items")
}

enum WalletStatus {
  ACTIVE
  SUSPENDED
  CLOSED
}

model Wallet {
  id                String    @id @default(cuid())
  userId            String    @unique
  balance           Decimal   @default(0.00) @db.Decimal(12, 2)
  availableBalance  Decimal   @default(0.00) @db.Decimal(12, 2)
  pendingBalance    Decimal   @default(0.00) @db.Decimal(12, 2)
  currency          String    @default("USD")
  status            WalletStatus @default(ACTIVE)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions      WalletTransaction[]
  withdrawals       Withdrawal[]

  @@map("wallets")
}

enum TransactionType {
  CREDIT
  DEBIT
  HOLD
  RELEASE
  FEE
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

model WalletTransaction {
  id                  String            @id @default(cuid())
  walletId            String
  orderId             String?
  type                TransactionType
  amount              Decimal           @db.Decimal(12, 2)
  fee                 Decimal           @default(0.00) @db.Decimal(12, 2)
  balanceAfter        Decimal           @db.Decimal(12, 2)
  status              TransactionStatus @default(PENDING)
  description         String?
  metadata            Json?
  kushkiTransactionId String?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  // Relations
  wallet              Wallet            @relation(fields: [walletId], references: [id], onDelete: Cascade)
  order               Order?            @relation(fields: [orderId], references: [id])

  @@index([walletId])  // ← Agregado índice
  @@index([orderId])   // ← Agregado índice
  @@index([status])    // ← Agregado índice
  @@map("wallet_transactions")
}

enum BankAccountType {
  SAVINGS
  CHECKING
}

enum DocumentType {
  CEDULA
  PASSPORT
  RUC
}

model BankAccount {
  id                String          @id @default(cuid())
  userId            String
  bankName          String
  bankCode          String
  accountNumber     String
  accountType       BankAccountType
  accountHolderName String
  documentType      DocumentType
  documentNumber    String
  isDefault         Boolean         @default(false)
  isVerified        Boolean         @default(false)
  kushkiAccountId   String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  // Relations
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  withdrawals       Withdrawal[]

  @@unique([userId, accountNumber])
  @@index([userId])    // ← Agregado índice adicional
  @@map("bank_accounts")
}

enum WithdrawalStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

model Withdrawal {
  id                String           @id @default(cuid())
  walletId          String
  bankAccountId     String
  amount            Decimal          @db.Decimal(12, 2)
  kushkiFee         Decimal          @db.Decimal(12, 2)
  netAmount         Decimal          @db.Decimal(12, 2)
  status            WithdrawalStatus @default(PENDING)
  kushkiTransferId  String?
  processingDate    DateTime?
  completedDate     DateTime?
  errorMessage      String?
  metadata          Json?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  // Relations
  wallet            Wallet           @relation(fields: [walletId], references: [id])
  bankAccount       BankAccount      @relation(fields: [bankAccountId], references: [id])

  @@index([walletId])       // ← Agregado índice
  @@index([bankAccountId])  // ← Agregado índice
  @@index([status])         // ← Agregado índice
  @@map("withdrawals")
}

model PointsTransaction {
  id          String   @id @default(cuid())
  userId      String
  points      Int
  type        String   // 'earned', 'redeemed', 'bonus'
  source      String   // 'order', 'referral', 'manual'
  sourceId    String?  // order_id, referral_id, etc.
  description String?
  createdAt   DateTime @default(now())

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])  // ← Agregado índice
  @@map("points_transactions")
}

enum NotificationType {
  ORDER_UPDATE
  PAYMENT_RECEIVED
  WITHDRAWAL_COMPLETED
  VERIFICATION_REQUIRED
  SYSTEM_MAINTENANCE
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
}

model Notification {
  id        String             @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  status    NotificationStatus @default(UNREAD)
  metadata  Json?
  createdAt DateTime           @default(now())
  readAt    DateTime?

  // Relations
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])  // ← Agregado índice
  @@index([status])  // ← Agregado índice
  @@map("notifications")
}

model SystemSetting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  type      String   // 'string', 'number', 'boolean', 'json'
  category  String   // 'general', 'payment', 'email', etc.
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])  // ← Agregado índice
  @@map("system_settings")
}

// Tokens de verificación
enum TokenType {
  EMAIL_VERIFICATION
  PASSWORD_RESET
  CHANGE_EMAIL
}

model VerificationToken {
  id        String     @id @default(cuid())
  userId    String
  token     String     @unique
  type      TokenType
  expiresAt DateTime
  isUsed    Boolean    @default(false)
  usedAt    DateTime?
  metadata  Json?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])    // ← Agregado índice
  @@index([expiresAt]) // ← Agregado índice
  @@index([type])      // ← Agregado índice
  @@map("verification_tokens")
}

// OAuth Accounts (Google, Facebook, etc.)
enum OAuthProvider {
  GOOGLE
  FACEBOOK
}

model OAuthAccount {
  id                String        @id @default(cuid())
  userId            String
  provider          OAuthProvider
  providerAccountId String        
  accessToken       String?       @db.Text
  refreshToken      String?       @db.Text
  expiresAt         DateTime?
  tokenType         String?
  scope             String?
  idToken           String?       @db.Text
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])    // ← Agregado índice
  @@map("oauth_accounts")
}

model RefreshToken {
  id          String   @id @default(cuid())
  token       String   @unique
  userId      String
  isActive    Boolean  @default(true)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relaciones
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Índices para optimizar consultas
  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model TokenBlacklist {
  id          String   @id @default(cuid())
  tokenHash   String   @unique // Hash SHA256 del token
  userId      String
  expiresAt   DateTime // Fecha de expiración del token original
  reason      String   // Razón por la cual se agregó a la blacklist
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relaciones
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Índices para optimizar consultas
  @@index([userId])
  @@index([expiresAt])
  @@index([tokenHash])
  @@map("token_blacklist")
}