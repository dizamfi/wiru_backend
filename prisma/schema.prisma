// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum UserType {
  PERSON
  COMPANY
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_VERIFICATION
}

model User {
  id                String     @id @default(cuid())
  email             String     @unique
  googleId          String?    @unique  // ← Agregado @unique
  facebookId        String?    @unique  // ← Agregado @unique
  password          String
  firstName         String
  lastName          String
  phone             String?
  avatar            String?
  role              UserRole   @default(USER)
  type              UserType   @default(PERSON)
  status            UserStatus @default(PENDING_VERIFICATION)
  isEmailVerified   Boolean    @default(false)
  emailVerifiedAt   DateTime?
  lastLoginAt       DateTime?
  referralCode      String     @unique
  referredBy        String?
  companyName       String?
  companyDocument   String?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  // Relations
  wallet              Wallet?
  orders              Order[]
  cart              Cart? 
  bankAccounts        BankAccount[]
  referrals           User[]     @relation("UserReferrals")
  referrer            User?      @relation("UserReferrals", fields: [referredBy], references: [referralCode])
  pointsTransactions  PointsTransaction[]
  notifications       Notification[]
  sessions            UserSession[]
  refreshTokens       RefreshToken[]
  tokenBlacklist      TokenBlacklist[]
  verificationTokens  VerificationToken[]
  oauthAccounts       OAuthAccount[]

  createdCategories   Category[]     // Categorías creadas por este usuario


  @@map("users")
}

model UserSession {
  id          String   @id @default(cuid())
  userId      String
  token       String   @unique
  accessToken String?  // ← Campo opcional para access token
  userAgent   String?
  ipAddress   String?
  isActive    Boolean  @default(true)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt  // ← Agregado @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])      // ← Agregado índice
  @@index([expiresAt])   // ← Agregado índice
  @@map("user_sessions")
}


enum CategoryType {
  COMPLETE_DEVICES      // Dispositivos Completos
  DISMANTLED_DEVICES    // Dispositivos Desarmables
}

enum CategoryStatus {
  ACTIVE
  INACTIVE
  DRAFT
}

model Category {
  id              String         @id @default(cuid())
  name            String         // "Bajo Grado", "Marrón", "Verde", etc.
  slug            String         @unique // "bajo-grado", "marron", "verde"
  description     String?        // Descripción detallada
  type            CategoryType   // COMPLETE_DEVICES o DISMANTLED_DEVICES
  status          CategoryStatus @default(ACTIVE)
  
  // Jerarquía flexible
  parentId        String?        // ID de la categoría padre
  parent          Category?      @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: Restrict)
  children        Category[]     @relation("CategoryHierarchy")
  
  // Metadatos de jerarquía (para consultas eficientes)
  level           Int            @default(0) // 0=raíz, 1=primer nivel, etc.
  path            String[]       @default([]) // ["dispositivos-desarmables", "bajo-grado", "marron"]
  fullPath        String         @default("") // "dispositivos-desarmables/bajo-grado/marron"
  
  // Propiedades visuales
  icon            String?        // Icono FontAwesome o similar
  color           String?        // Color hex para UI
  images          String[]       @default([]) // Imágenes de referencia
  thumbnailImage  String?        // Imagen principal/thumbnail
  
  // Configuración de negocio
  isLeaf          Boolean        @default(false) // true si es categoría final (seleccionable)
  sortOrder       Int            @default(0)     // Orden de visualización
  
  // Para dispositivos desarmables - precios base
  pricePerKg      Decimal?       @db.Decimal(10, 2) // Precio por kg (solo categorías hoja)
  minWeight       Decimal?       @db.Decimal(8, 3)  // Peso mínimo aceptado
  maxWeight       Decimal?       @db.Decimal(8, 3)  // Peso máximo sugerido
  
  // Metadatos adicionales (JSON flexible)
  metadata        Json?          // Propiedades específicas de la categoría
  
  // Timestamps
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  createdBy       String?        // ID del usuario que la creó
  
  // Relations
  orderItems      OrderItem[]    // Items de órdenes que usan esta categoría
  creator         User?          @relation(fields: [createdBy], references: [id])
  cartItems       CartItem[] 
  
  // ← AGREGAR ESTA LÍNEA:
  config          CategoryConfig? // Configuración específica de la categoría

  @@index([type])
  @@index([parentId])
  @@index([level])
  @@index([status])
  @@index([isLeaf])
  @@index([fullPath])
  @@map("categories")
}

model CategoryConfig {
  id              String    @id @default(cuid())
  categoryId      String    @unique
  category        Category  @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  // Configuraciones específicas
  requiresImages  Boolean   @default(true)  // Si requiere fotos
  maxImages       Int       @default(5)     // Máximo de fotos
  requiresWeight  Boolean   @default(true)  // Si requiere peso
  allowMixed      Boolean   @default(false) // Si permite mezcla con otras categorías
  
  // Validaciones
  validationRules Json?     // Reglas específicas de validación
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@map("category_configs")
}

// Enums para condiciones de dispositivos
enum DeviceCondition {
  EXCELLENT     // Excelente - Como nuevo
  VERY_GOOD     // Muy bueno - Signos mínimos de uso
  GOOD          // Bueno - Uso normal, funcional
  FAIR          // Regular - Uso evidente pero funcional
  POOR          // Malo - Funcional pero con problemas
  BROKEN        // Roto - No funcional, solo para partes
  FOR_PARTS     // Solo para repuestos
}

enum OrderStatus {
  PENDING
  CONFIRMED
  IN_TRANSIT
  DELIVERED
  VERIFIED
  PAID
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum DeliveryMethod {
  PICKUP_POINT
  HOME_PICKUP
}

model Order {
  id                String         @id @default(cuid())
  orderNumber       String         @unique
  userId            String
  status            OrderStatus    @default(PENDING)
  paymentStatus     PaymentStatus  @default(PENDING)
  deliveryMethod    DeliveryMethod
  estimatedTotal    Decimal        @db.Decimal(10, 2)
  finalTotal        Decimal?       @db.Decimal(10, 2)
  estimatedWeight   Decimal        @db.Decimal(8, 3)
  actualWeight      Decimal?       @db.Decimal(8, 3)
  notes             String?
  
  // Pickup/Delivery info
  pickupAddress     Json?
  pickupDate        DateTime?
  deliveryDate      DateTime?
  trackingNumber    String?
  qrCode            String?
  
  // Servientrega integration
  servientregaGuide String?
  servientregaStatus String?
  
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  // Relations
  user              User           @relation(fields: [userId], references: [id])
  orderItems        OrderItem[]
  walletTransactions WalletTransaction[]

  @@index([userId])        // ← Agregado índice
  @@index([status])        // ← Agregado índice
  @@index([orderNumber])   // ← Agregado índice
  @@map("orders")
}

model OrderItem {
  id              String   @id @default(cuid())
  orderId         String
  categoryId      String
  
  // Información del dispositivo/material
  deviceName      String?        // Nombre específico del dispositivo
  brand           String?        // Marca
  model           String?        // Modelo
  condition       DeviceCondition? // Estado del dispositivo
  
  // Campos específicos según clasificación
  processorModel  String?        // Para Pentium III/IV
  socketType      String?        // Tipo de socket
  frequency       String?        // Frecuencia del procesador
  coreCount       Int?           // Número de núcleos
  storageCapacity String?        // Para tablets/laptops
  processorType   String?        // Tipo de procesador
  decoderType     String?        // Tipo de decodificador
  resolution      String?        // Resolución soportada
  deviceType      String?        // Tipo específico de dispositivo
  readerType      String?        // Tipo de lector
  printerType     String?        // Tipo de impresora
  connectivity    String?        // Tipo de conectividad
  systemType      String?        // Tipo de sistema
  manufacturer    String?        // Fabricante específico
  networkStandard String?        // Estándar de red
  equipmentType   String?        // Tipo de equipo
  networkTier     String?        // Nivel de red
  capacity        String?        // Capacidad del equipo
  approximateAge  String?        // Edad aproximada
  componentType   String?        // Tipo de componente
  authenticity    String?        // Autenticidad del componente
  formFactor      String?        // Factor de forma
  brandFeatures   String?        // Características de marca
  damageType      String?        // Tipo de daño
  systemModel     String?        // Modelo del sistema
  enterpriseGrade Boolean?       // Si es grado empresarial
  
  // Cantidades y pesos
  quantity        Int            @default(1)    // Cantidad de dispositivos
  estimatedWeight Decimal        @db.Decimal(8, 3)
  actualWeight    Decimal?       @db.Decimal(8, 3)
  
  // Precios
  pricePerKg      Decimal        @db.Decimal(10, 2)
  pricePerUnit    Decimal?       @db.Decimal(10, 2)  // Para dispositivos completos
  estimatedValue  Decimal        @db.Decimal(10, 2)
  actualValue     Decimal?       @db.Decimal(10, 2)
  
  // Evidencia y notas
  images          String[]       @default([])
  notes           String?
  
  // Accesorios incluidos (para dispositivos completos)
  accessories     String[]       @default([])  // ["charger", "box", "documents"]
  
  // Metadata adicional
  metadata        Json?
  
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Relations
  order           Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  category        Category       @relation(fields: [categoryId], references: [id])

  // Índices corregidos (solo campos escalares, no de relación)
  @@index([orderId])
  @@index([categoryId])
  @@index([deviceName])     // Cambiado de condition a deviceName
  @@index([brand])          // Agregado para búsquedas
  @@index([condition])      // Ahora funcionará porque DeviceCondition es un enum
  @@map("order_items")
}

enum WalletStatus {
  ACTIVE
  SUSPENDED
  CLOSED
}

model Wallet {
  id                String    @id @default(cuid())
  userId            String    @unique
  balance           Decimal   @default(0.00) @db.Decimal(12, 2)
  availableBalance  Decimal   @default(0.00) @db.Decimal(12, 2)
  pendingBalance    Decimal   @default(0.00) @db.Decimal(12, 2)
  currency          String    @default("USD")
  status            WalletStatus @default(ACTIVE)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions      WalletTransaction[]
  withdrawals       Withdrawal[]

  @@map("wallets")
}

enum TransactionType {
  CREDIT
  DEBIT
  HOLD
  RELEASE
  FEE
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

model WalletTransaction {
  id                  String            @id @default(cuid())
  walletId            String
  orderId             String?
  type                TransactionType
  amount              Decimal           @db.Decimal(12, 2)
  fee                 Decimal           @default(0.00) @db.Decimal(12, 2)
  balanceAfter        Decimal           @db.Decimal(12, 2)
  status              TransactionStatus @default(PENDING)
  description         String?
  metadata            Json?
  kushkiTransactionId String?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  // Relations
  wallet              Wallet            @relation(fields: [walletId], references: [id], onDelete: Cascade)
  order               Order?            @relation(fields: [orderId], references: [id])

  @@index([walletId])  // ← Agregado índice
  @@index([orderId])   // ← Agregado índice
  @@index([status])    // ← Agregado índice
  @@map("wallet_transactions")
}

enum BankAccountType {
  SAVINGS
  CHECKING
}

enum DocumentType {
  CEDULA
  PASSPORT
  RUC
}

model BankAccount {
  id                String          @id @default(cuid())
  userId            String
  bankName          String
  bankCode          String
  accountNumber     String
  accountType       BankAccountType
  accountHolderName String
  documentType      DocumentType
  documentNumber    String
  isDefault         Boolean         @default(false)
  isVerified        Boolean         @default(false)
  kushkiAccountId   String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  // Relations
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  withdrawals       Withdrawal[]

  @@unique([userId, accountNumber])
  @@index([userId])    // ← Agregado índice adicional
  @@map("bank_accounts")
}

enum WithdrawalStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

model Withdrawal {
  id                String           @id @default(cuid())
  walletId          String
  bankAccountId     String
  amount            Decimal          @db.Decimal(12, 2)
  kushkiFee         Decimal          @db.Decimal(12, 2)
  netAmount         Decimal          @db.Decimal(12, 2)
  status            WithdrawalStatus @default(PENDING)
  kushkiTransferId  String?
  processingDate    DateTime?
  completedDate     DateTime?
  errorMessage      String?
  metadata          Json?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  // Relations
  wallet            Wallet           @relation(fields: [walletId], references: [id])
  bankAccount       BankAccount      @relation(fields: [bankAccountId], references: [id])

  @@index([walletId])       // ← Agregado índice
  @@index([bankAccountId])  // ← Agregado índice
  @@index([status])         // ← Agregado índice
  @@map("withdrawals")
}

model PointsTransaction {
  id          String   @id @default(cuid())
  userId      String
  points      Int
  type        String   // 'earned', 'redeemed', 'bonus'
  source      String   // 'order', 'referral', 'manual'
  sourceId    String?  // order_id, referral_id, etc.
  description String?
  createdAt   DateTime @default(now())

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])  // ← Agregado índice
  @@map("points_transactions")
}

enum NotificationType {
  ORDER_UPDATE
  PAYMENT_RECEIVED
  WITHDRAWAL_COMPLETED
  VERIFICATION_REQUIRED
  SYSTEM_MAINTENANCE
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
}

model Notification {
  id        String             @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  status    NotificationStatus @default(UNREAD)
  metadata  Json?
  createdAt DateTime           @default(now())
  readAt    DateTime?

  // Relations
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])  // ← Agregado índice
  @@index([status])  // ← Agregado índice
  @@map("notifications")
}

model SystemSetting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  type      String   // 'string', 'number', 'boolean', 'json'
  category  String   // 'general', 'payment', 'email', etc.
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])  // ← Agregado índice
  @@map("system_settings")
}

// Tokens de verificación
enum TokenType {
  EMAIL_VERIFICATION
  PASSWORD_RESET
  CHANGE_EMAIL
}

model VerificationToken {
  id        String     @id @default(cuid())
  userId    String
  token     String     @unique
  type      TokenType
  expiresAt DateTime
  isUsed    Boolean    @default(false)
  usedAt    DateTime?
  metadata  Json?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])    // ← Agregado índice
  @@index([expiresAt]) // ← Agregado índice
  @@index([type])      // ← Agregado índice
  @@map("verification_tokens")
}

// OAuth Accounts (Google, Facebook, etc.)
enum OAuthProvider {
  GOOGLE
  FACEBOOK
}

model OAuthAccount {
  id                String        @id @default(cuid())
  userId            String
  provider          OAuthProvider
  providerAccountId String        
  accessToken       String?       @db.Text
  refreshToken      String?       @db.Text
  expiresAt         DateTime?
  tokenType         String?
  scope             String?
  idToken           String?       @db.Text
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])    // ← Agregado índice
  @@map("oauth_accounts")
}

model RefreshToken {
  id          String   @id @default(cuid())
  token       String   @unique
  userId      String
  isActive    Boolean  @default(true)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relaciones
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Índices para optimizar consultas
  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model TokenBlacklist {
  id          String   @id @default(cuid())
  tokenHash   String   @unique // Hash SHA256 del token
  userId      String
  expiresAt   DateTime // Fecha de expiración del token original
  reason      String   // Razón por la cual se agregó a la blacklist
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relaciones
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Índices para optimizar consultas
  @@index([userId])
  @@index([expiresAt])
  @@index([tokenHash])
  @@map("token_blacklist")
}



model Cart {
  id        String     @id @default(cuid())
  userId    String     @unique
  items     CartItem[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("carts")
}

model CartItem {
  id              String   @id @default(cuid())
  cartId          String
  categoryId      String
  categoryName    String
  categoryPath    String
  weight          Decimal  @db.Decimal(8, 3)
  quantity        Int      @default(1)
  pricePerKg      Decimal  @db.Decimal(10, 2)
  estimatedValue  Decimal  @db.Decimal(10, 2)
  images          String[] // URLs de Cloudinary
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  cart     Cart     @relation(fields: [cartId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id])

  @@index([cartId])
  @@index([categoryId])
  @@map("cart_items")
}